import os
import glob
import re
import markdown
from bs4 import BeautifulSoup
from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_UNDERLINE

def preprocess_markdown(md_content):
    """
    1. If a line is enclosed entirely in ****...**** or **...**, convert it to '# heading'.
    2. If a line matches '**title** : something', convert it so the entire line is bold.
    3. Leave other lines intact so normal Markdown rules (#, ##, lists, etc.) still apply.
    """
    lines = md_content.split('\n')
    new_lines = []

    # Regex for line fully enclosed in ****...****
    pattern_4stars = re.compile(r'^\*\*\*\*(.+)\*\*\*\*$')
    # Regex for line fully enclosed in **...**
    pattern_2stars = re.compile(r'^\*\*(.+)\*\*$')
    # Regex for line like '**title** : rest of line'
    pattern_title_colon = re.compile(r'^\*\*(.+)\*\*\s*:\s*(.*)$')

    for line in lines:
        stripped = line.strip()

        # 1) Check if entire line is ****Something****
        match_4 = pattern_4stars.match(stripped)
        if match_4:
            text = match_4.group(1).strip()
            # Convert to a Markdown H1
            new_lines.append(f"# {text}")
            continue

        # 2) Check if entire line is **Something**
        match_2 = pattern_2stars.match(stripped)
        if match_2:
            text = match_2.group(1).strip()
            # Convert to a Markdown H1
            new_lines.append(f"# {text}")
            continue

        # 3) Check if line is like '**title** : rest'
        match_title_colon = pattern_title_colon.match(stripped)
        if match_title_colon:
            title_text = match_title_colon.group(1).strip()
            rest_text = match_title_colon.group(2).strip()
            # Make the entire line bold => **title: rest**
            new_lines.append(f"**{title_text}: {rest_text}**")
            continue

        # Otherwise, leave line as is
        new_lines.append(line)

    return "\n".join(new_lines)

def md_to_docx(md_files, output_docx, logo_path):
    doc = Document()

    # Skin color (light orange)
    skin_color = RGBColor(255, 165, 0)

    # --- Add Header ---
    section = doc.sections[0]
    header = section.header
    
    # Left side text
    paragraph_left = header.paragraphs[0]
    paragraph_left.alignment = WD_ALIGN_PARAGRAPH.LEFT
    run = paragraph_left.add_run("ABC")
    run.font.name = 'Calibri'
    run.font.size = Pt(11)

    # Right side image
    paragraph_right = header.add_paragraph()
    paragraph_right.alignment = WD_ALIGN_PARAGRAPH.RIGHT
    
    # Add logo to the right side of the header
    if os.path.exists(logo_path):
        # Adjust image width (you can modify Inches value as needed)
        paragraph_right.add_run().add_picture(logo_path, width=Inches(1.5))

    for md_file in md_files:
        with open(md_file, "r") as f:
            original_md_content = f.read()

        # --- PREPROCESS the Markdown text ---
        preprocessed_content = preprocess_markdown(original_md_content)

        # --- Convert the preprocessed Markdown to HTML ---
        html_content = markdown.markdown(preprocessed_content, extensions=["tables"])
        soup = BeautifulSoup(html_content, "html.parser")

        # Now parse the HTML and build the DOCX
        for element in soup.children:
            # ---- HEADINGS (Generated by #, ##, etc.) ----
            if element.name in ["h1", "h2", "h3", "h4", "h5", "h6"]:
                p = doc.add_paragraph()
                run = p.add_run(element.get_text())

                # Set font to Calibri
                run.font.name = 'Calibri (Body)'
                run.font.bold = True

                # Specific styling for different heading levels
                if element.name == "h1":
                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                    run.font.size = Pt(14)

                    # Add skin color long box
                    paragraph_format = p.paragraph_format
                    paragraph_format.left_indent = Pt(0)
                    paragraph_format.right_indent = Pt(0)
                    paragraph_format.space_before = Pt(6)
                    paragraph_format.space_after = Pt(6)

                    # Shading for header
                    paragraph_format.background_color = skin_color

                elif element.name == "h2":
                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                    run.font.size = Pt(12)
                    run.font.underline = WD_UNDERLINE.SINGLE
                    run.font.color.rgb = skin_color

                elif element.name == "h3":
                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                    run.font.size = Pt(11)

                else:
                    # h4, h5, h6
                    p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                    run.font.size = Pt(11)

            # ---- PARAGRAPHS ----
            elif element.name == "p":
                p = doc.add_paragraph(element.get_text())
                p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

                # Set font to Calibri, size 11
                for run in p.runs:
                    run.font.name = 'Calibri'
                    run.font.size = Pt(11)

            # ---- UNORDERED LISTS ----
            elif element.name == "ul":
                list_items = element.find_all("li")
                for li in list_items:
                    li_text = li.get_text().strip()
                    p = doc.add_paragraph(li_text)
                    p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

                    # Set font to Calibri, size 11
                    for run in p.runs:
                        run.font.name = 'Calibri'
                        run.font.size = Pt(11)

            # ---- ORDERED LISTS ----
            elif element.name == "ol":
                list_items = element.find_all("li")
                for li in list_items:
                    li_text = li.get_text().strip()
                    p = doc.add_paragraph(li_text)
                    p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

                    # Set font to Calibri, size 11
                    for run in p.runs:
                        run.font.name = 'Calibri'
                        run.font.size = Pt(11)

            # ---- TABLES ----
            elif element.name == "table":
                rows = element.find_all("tr")
                if rows:
                    header_cols = rows[0].find_all(["th", "td"])
                    num_cols = len(header_cols)

                    table = doc.add_table(rows=len(rows), cols=num_cols)
                    for row_idx, row in enumerate(rows):
                        columns = row.find_all(["th", "td"])
                        for col_idx, cell in enumerate(columns):
                            cell_text = cell.get_text()
                            table.cell(row_idx, col_idx).text = cell_text

                            # Set font to Calibri, size 11 for table cells
                            for paragraph in table.cell(row_idx, col_idx).paragraphs:
                                for run in paragraph.runs:
                                    run.font.name = 'Calibri'
                                    run.font.size = Pt(11)

                doc.add_paragraph("")

        # Add spacing after each file if desired
        doc.add_paragraph("\n")

    # --- Add Footer ---
    footer = section.footer
    paragraph = footer.paragraphs[0]
    paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
    run = paragraph.add_run("Copyright Â© 2025, Nitor Infotech Pvt. Ltd., All Rights Reserved. Confidential")
    run.font.name = 'Calibri'
    run.font.size = Pt(10)

    doc.save(output_docx)

# Example usage
if __name__ == "__main__":
    md_files = glob.glob(r"server\app\pipelines\proposal_generator\proposals\*.md")
    logo_path = r"server\app\pipelines\proposal_generator\nitor_logo.png"
    md_to_docx(md_files, "Nitor_proposal.docx", logo_path)